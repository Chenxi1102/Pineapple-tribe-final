results$gender[results$gender == "F"] <- "Female"
gender_plot <- ggplot(data = results) +
geom_bar(mapping = aes(x = gender), fill = "grey") +
coord_flip() +
labs(y = "# of Representatives") +
## 6. pick a representative.
##
##    Note: this representative must correspond to the state the address points to.  Different
##    states have different number of representatives, I recommend to pick one of these at random.
##
## 7. get this representative's info
##
##    Consult the 'members' endpoint and the examples related to information about a particular member.
##
## 8. get her recent votes.
##
##    In order to get the percentage of votes with majority, you have:
##    a) get the member's voting data (see the same API documentation)
##    b) pick the most recent votes (the data includes vote date)
##    c) find her position (Yes/No)
##    d) find the total votes (yes/no)
##    Consult the example in the API documentation that includes the relevant JSON result.
##
library("httr")
library("httr")
source("keys.R")
### This file contains your main code.
### Feel free to rename it, or split it into several files.
###
### Your final product should contain the code along the following lines:
##    ---------- Google Civic Information API ----------
## 1. create the google civic platform request and httr::GET() the result
##    you need to include your api key in the request.  See the documentation
##    https://developers.google.com/civic-information/
##    https://developers.google.com/civic-information/docs/v2/
##    in particular the reference section.
library("httr")
source("keys.R")
base <- "https://www.googleapis.com/civicinfo/v2/representatives"
google_civic_response <- httr::GET(base, query = list(address = address, key = google.key))
##    Note: you can try the requests by submitting these through your browser by entering the
##    full query (base url, endpoint, query) in your browser's address bar.
##    If it is correct correct, it will display the corresponding JSON data.  If
##    incorrect, you get an error message.
## 2. extract the elected officials' data from the result
##    The data contains many relevant variables, including normalized address,
##    'offices' and 'officials'.  In order to attach the officials (people)
##    with offices (jobs), I recommend to use dplyr joins (what would be the key?)
##    More about joins in
##    https://info201.github.io/dplyr.html#joins
##    http://r4ds.had.co.nz/relational-data.html
library(jsonlite)
library(dplyr)
library(tidyr)
library(stringr)
data <- httr::content(google_civic_response, "text") %>% fromJSON()
officials <- data$officials
offices <- data$offices
officialIndices_list <- offices$officialIndices
position_vector <- grep(":", officialIndices_list)
time <- nrow(offices)
empty_df <- data.frame(stringsAsFactors = FALSE)
for (i in 1:time) {
one_row_df <- offices %>% filter(row_number() == i)
if (i %in% position_vector) {
empty_df <- rbind(empty_df, one_row_df)
empty_df <- rbind(empty_df, one_row_df)
} else {
empty_df <- rbind(empty_df, one_row_df)
}
}
combined_df <- bind_cols(empty_df, officials)
combined_df <- combined_df %>% select(name, name1, party, phones, photoUrl, emails)
combined_df <- combined_df[ ,c(1, 2, 3, 6, 4, 5)]
new_col_names <- c('Name', 'Position', 'Party', 'Email', 'Phone', 'Photo')
colnames(combined_df) <- new_col_names
## 3. transform the data into a well formatted table
##    I recommend you transform the data into markdown strings.  For instance,
##    to display a html link as a link in the markdown file, you may want to
##    embed it between "[](" and ")".
##
##    You may want to consider improved table printing, look for details at the rmarkdown
##    page at
##    http://rmarkdown.rstudio.com/index.html
##
photo_list <- combined_df$Photo
for (i in 1:length(photo_list)) {
string_value <- photo_list[[i]]
photo_list[[i]] <- paste0("![Image](", string_value, ")")
}
combined_df <- combined_df %>%
mutate(Photo = photo_list)
new_col_names <- c('Position', 'Name', 'Party', 'Email', 'Phone', 'Photo')
colnames(combined_df) <- new_col_names
combined_df <- combined_df[ ,c(2, 1, 3, 4, 5, 6)]
combined_df$Photo[combined_df$Photo == "![Image](NA)"] <- "-"
combined_df$Email[combined_df$Email == "NULL"] <- "-"
combined_df <- combined_df %>% mutate(urls = officials$urls)
for (i in 1:nrow(combined_df)) {
combined_df$Position[[i]] <- paste0("[", combined_df$Position[[i]], "]", "(", combined_df$urls[[i]], ")")
}
combined_df <- combined_df %>% select(Name, Position, Party, Email, Phone, Photo)
## -------------------- propublica --------------------
## 4. Get state representatives from propublica congress API
##    you need the respective API key.
##
##    Note1: the api key must be sent as 'X-API-Key'.  No other name, such as 'api-key'
##    will work.
##
##    Note2: Propublica API has several endpoints.  The relevant one here is 'members'.
##    It which allows you to get lists of members, lists of members by state,
##    specific member by id, voting data, and more.
##
##    Read the documentation:
##    https://projects.propublica.org/api-docs/congress-api/members/
base <- "https://api.propublica.org/congress/v1/members/house/CA/current.json"
propublica_response <- GET(base, httr::add_headers("X-API-Key" = propublica.key))
## 5. transform it in a form you can use for visualizations.
propublica_data <- httr::content(propublica_response, "text") %>% fromJSON()
results <- propublica_data$results
##    For the first visualization you have to extract the party affiliation of all the members
##    and make a histogram of that data.
library(ggplot2)
results$party[results$party == "D"] <- "Democratic"
results$party[results$party == "R"] <- "Republican"
party_plot <- ggplot(data = results) +
geom_bar(mapping = aes(x = party, fill = party)) +
coord_flip() +
labs(y = "# of Representatives") +
scale_fill_manual(values=c("blue", "red"))
results$gender[results$gender == "M"] <- "Male"
results$gender[results$gender == "F"] <- "Female"
gender_plot <- ggplot(data = results) +
geom_bar(mapping = aes(x = gender), fill = "grey") +
coord_flip() +
labs(y = "# of Representatives") +
## 6. pick a representative.
##
##    Note: this representative must correspond to the state the address points to.  Different
##    states have different number of representatives, I recommend to pick one of these at random.
##
## 7. get this representative's info
##
##    Consult the 'members' endpoint and the examples related to information about a particular member.
##
## 8. get her recent votes.
##
##    In order to get the percentage of votes with majority, you have:
##    a) get the member's voting data (see the same API documentation)
##    b) pick the most recent votes (the data includes vote date)
##    c) find her position (Yes/No)
##    d) find the total votes (yes/no)
##    Consult the example in the API documentation that includes the relevant JSON result.
##
### This file contains your main code.
### Feel free to rename it, or split it into several files.
###
### Your final product should contain the code along the following lines:
##    ---------- Google Civic Information API ----------
## 1. create the google civic platform request and httr::GET() the result
##    you need to include your api key in the request.  See the documentation
##    https://developers.google.com/civic-information/
##    https://developers.google.com/civic-information/docs/v2/
##    in particular the reference section.
library("httr")
source("keys.R")
base <- "https://www.googleapis.com/civicinfo/v2/representatives"
google_civic_response <- httr::GET(base, query = list(address = address, key = google.key))
##    Note: you can try the requests by submitting these through your browser by entering the
##    full query (base url, endpoint, query) in your browser's address bar.
##    If it is correct correct, it will display the corresponding JSON data.  If
##    incorrect, you get an error message.
## 2. extract the elected officials' data from the result
##    The data contains many relevant variables, including normalized address,
##    'offices' and 'officials'.  In order to attach the officials (people)
##    with offices (jobs), I recommend to use dplyr joins (what would be the key?)
##    More about joins in
##    https://info201.github.io/dplyr.html#joins
##    http://r4ds.had.co.nz/relational-data.html
library(jsonlite)
library(dplyr)
library(tidyr)
library(stringr)
data <- httr::content(google_civic_response, "text") %>% fromJSON()
officials <- data$officials
offices <- data$offices
officialIndices_list <- offices$officialIndices
position_vector <- grep(":", officialIndices_list)
time <- nrow(offices)
empty_df <- data.frame(stringsAsFactors = FALSE)
for (i in 1:time) {
one_row_df <- offices %>% filter(row_number() == i)
if (i %in% position_vector) {
empty_df <- rbind(empty_df, one_row_df)
empty_df <- rbind(empty_df, one_row_df)
} else {
empty_df <- rbind(empty_df, one_row_df)
}
}
combined_df <- bind_cols(empty_df, officials)
combined_df <- combined_df %>% select(name, name1, party, phones, photoUrl, emails)
combined_df <- combined_df[ ,c(1, 2, 3, 6, 4, 5)]
new_col_names <- c('Name', 'Position', 'Party', 'Email', 'Phone', 'Photo')
colnames(combined_df) <- new_col_names
## 3. transform the data into a well formatted table
##    I recommend you transform the data into markdown strings.  For instance,
##    to display a html link as a link in the markdown file, you may want to
##    embed it between "[](" and ")".
##
##    You may want to consider improved table printing, look for details at the rmarkdown
##    page at
##    http://rmarkdown.rstudio.com/index.html
##
photo_list <- combined_df$Photo
for (i in 1:length(photo_list)) {
string_value <- photo_list[[i]]
photo_list[[i]] <- paste0("![Image](", string_value, ")")
}
combined_df <- combined_df %>%
mutate(Photo = photo_list)
new_col_names <- c('Position', 'Name', 'Party', 'Email', 'Phone', 'Photo')
colnames(combined_df) <- new_col_names
combined_df <- combined_df[ ,c(2, 1, 3, 4, 5, 6)]
combined_df$Photo[combined_df$Photo == "![Image](NA)"] <- "-"
combined_df$Email[combined_df$Email == "NULL"] <- "-"
combined_df <- combined_df %>% mutate(urls = officials$urls)
for (i in 1:nrow(combined_df)) {
combined_df$Position[[i]] <- paste0("[", combined_df$Position[[i]], "]", "(", combined_df$urls[[i]], ")")
}
combined_df <- combined_df %>% select(Name, Position, Party, Email, Phone, Photo)
## -------------------- propublica --------------------
## 4. Get state representatives from propublica congress API
##    you need the respective API key.
##
##    Note1: the api key must be sent as 'X-API-Key'.  No other name, such as 'api-key'
##    will work.
##
##    Note2: Propublica API has several endpoints.  The relevant one here is 'members'.
##    It which allows you to get lists of members, lists of members by state,
##    specific member by id, voting data, and more.
##
##    Read the documentation:
##    https://projects.propublica.org/api-docs/congress-api/members/
base <- "https://api.propublica.org/congress/v1/members/house/CA/current.json"
propublica_response <- GET(base, httr::add_headers("X-API-Key" = propublica.key))
## 5. transform it in a form you can use for visualizations.
propublica_data <- httr::content(propublica_response, "text") %>% fromJSON()
results <- propublica_data$results
##    For the first visualization you have to extract the party affiliation of all the members
##    and make a histogram of that data.
library(ggplot2)
results$party[results$party == "D"] <- "Democratic"
results$party[results$party == "R"] <- "Republican"
party_plot <- ggplot(data = results) +
geom_bar(mapping = aes(x = party, fill = party)) +
coord_flip() +
labs(y = "# of Representatives") +
scale_fill_manual(values=c("blue", "red"))
results$gender[results$gender == "M"] <- "Male"
results$gender[results$gender == "F"] <- "Female"
gender_plot <- ggplot(data = results) +
geom_bar(mapping = aes(x = gender), fill = "grey") +
coord_flip() +
labs(y = "# of Representatives") +
## 6. pick a representative.
##
##    Note: this representative must correspond to the state the address points to.  Different
##    states have different number of representatives, I recommend to pick one of these at random.
##
## 7. get this representative's info
##
##    Consult the 'members' endpoint and the examples related to information about a particular member.
##
## 8. get her recent votes.
##
##    In order to get the percentage of votes with majority, you have:
##    a) get the member's voting data (see the same API documentation)
##    b) pick the most recent votes (the data includes vote date)
##    c) find her position (Yes/No)
##    d) find the total votes (yes/no)
##    Consult the example in the API documentation that includes the relevant JSON result.
##
### This file contains your main code.
### Feel free to rename it, or split it into several files.
###
### Your final product should contain the code along the following lines:
##    ---------- Google Civic Information API ----------
## 1. create the google civic platform request and httr::GET() the result
##    you need to include your api key in the request.  See the documentation
##    https://developers.google.com/civic-information/
##    https://developers.google.com/civic-information/docs/v2/
##    in particular the reference section.
library("httr")
source("keys.R")
base <- "https://www.googleapis.com/civicinfo/v2/representatives"
google_civic_response <- httr::GET(base, query = list(address = address, key = google.key))
##    Note: you can try the requests by submitting these through your browser by entering the
##    full query (base url, endpoint, query) in your browser's address bar.
##    If it is correct correct, it will display the corresponding JSON data.  If
##    incorrect, you get an error message.
## 2. extract the elected officials' data from the result
##    The data contains many relevant variables, including normalized address,
##    'offices' and 'officials'.  In order to attach the officials (people)
##    with offices (jobs), I recommend to use dplyr joins (what would be the key?)
##    More about joins in
##    https://info201.github.io/dplyr.html#joins
##    http://r4ds.had.co.nz/relational-data.html
library(jsonlite)
library(dplyr)
library(tidyr)
library(stringr)
data <- httr::content(google_civic_response, "text") %>% fromJSON()
officials <- data$officials
offices <- data$offices
officialIndices_list <- offices$officialIndices
position_vector <- grep(":", officialIndices_list)
time <- nrow(offices)
empty_df <- data.frame(stringsAsFactors = FALSE)
for (i in 1:time) {
one_row_df <- offices %>% filter(row_number() == i)
if (i %in% position_vector) {
empty_df <- rbind(empty_df, one_row_df)
empty_df <- rbind(empty_df, one_row_df)
} else {
empty_df <- rbind(empty_df, one_row_df)
}
}
combined_df <- bind_cols(empty_df, officials)
combined_df <- combined_df %>% select(name, name1, party, phones, photoUrl, emails)
combined_df <- combined_df[ ,c(1, 2, 3, 6, 4, 5)]
new_col_names <- c('Name', 'Position', 'Party', 'Email', 'Phone', 'Photo')
colnames(combined_df) <- new_col_names
## 3. transform the data into a well formatted table
##    I recommend you transform the data into markdown strings.  For instance,
##    to display a html link as a link in the markdown file, you may want to
##    embed it between "[](" and ")".
##
##    You may want to consider improved table printing, look for details at the rmarkdown
##    page at
##    http://rmarkdown.rstudio.com/index.html
##
photo_list <- combined_df$Photo
for (i in 1:length(photo_list)) {
string_value <- photo_list[[i]]
photo_list[[i]] <- paste0("![Image](", string_value, ")")
}
combined_df <- combined_df %>%
mutate(Photo = photo_list)
new_col_names <- c('Position', 'Name', 'Party', 'Email', 'Phone', 'Photo')
colnames(combined_df) <- new_col_names
combined_df <- combined_df[ ,c(2, 1, 3, 4, 5, 6)]
combined_df$Photo[combined_df$Photo == "![Image](NA)"] <- "-"
combined_df$Email[combined_df$Email == "NULL"] <- "-"
combined_df <- combined_df %>% mutate(urls = officials$urls)
for (i in 1:nrow(combined_df)) {
combined_df$Position[[i]] <- paste0("[", combined_df$Position[[i]], "]", "(", combined_df$urls[[i]], ")")
}
combined_df <- combined_df %>% select(Name, Position, Party, Email, Phone, Photo)
## -------------------- propublica --------------------
## 4. Get state representatives from propublica congress API
##    you need the respective API key.
##
##    Note1: the api key must be sent as 'X-API-Key'.  No other name, such as 'api-key'
##    will work.
##
##    Note2: Propublica API has several endpoints.  The relevant one here is 'members'.
##    It which allows you to get lists of members, lists of members by state,
##    specific member by id, voting data, and more.
##
##    Read the documentation:
##    https://projects.propublica.org/api-docs/congress-api/members/
base <- "https://api.propublica.org/congress/v1/members/house/CA/current.json"
propublica_response <- GET(base, httr::add_headers("X-API-Key" = propublica.key))
## 5. transform it in a form you can use for visualizations.
propublica_data <- httr::content(propublica_response, "text") %>% fromJSON()
results <- propublica_data$results
##    For the first visualization you have to extract the party affiliation of all the members
##    and make a histogram of that data.
library(ggplot2)
results$party[results$party == "D"] <- "Democratic"
results$party[results$party == "R"] <- "Republican"
party_plot <- ggplot(data = results) +
geom_bar(mapping = aes(x = party, fill = party)) +
coord_flip() +
labs(y = "# of Representatives") +
scale_fill_manual(values=c("blue", "red"))
results$gender[results$gender == "M"] <- "Male"
results$gender[results$gender == "F"] <- "Female"
gender_plot <- ggplot(data = results) +
geom_bar(mapping = aes(x = gender), fill = "grey") +
coord_flip() +
labs(y = "# of Representatives") +
## 6. pick a representative.
##
##    Note: this representative must correspond to the state the address points to.  Different
##    states have different number of representatives, I recommend to pick one of these at random.
##
## 7. get this representative's info
##
##    Consult the 'members' endpoint and the examples related to information about a particular member.
##
## 8. get her recent votes.
##
##    In order to get the percentage of votes with majority, you have:
##    a) get the member's voting data (see the same API documentation)
##    b) pick the most recent votes (the data includes vote date)
##    c) find her position (Yes/No)
##    d) find the total votes (yes/no)
##    Consult the example in the API documentation that includes the relevant JSON result.
##
1+1
ssh moyiran@info201.ischool.uw.edu
ssh
q()
install.packages("shiny");
library("shiny");
runApp('Untitled.R')
install.packages("shiny")
library(shiny); runApp('Untitled.R')
runApp('Untitled.R')
library("shiny")
ui <- fluidPage(   # UI is a fluid page
titlePanel("My Title"),  # include panel with the title (also sets browser title)
sidebarLayout(   # layout the page in two columns
sidebarPanel(  # specify content for the "sidebar" column
p("sidebar panel content goes here")
),
mainPanel(     # specify content for the "main" column
p("main panel content goes here")
)
)
)
ui <- fluidPage(   # UI is a fluid page
titlePanel("My Title"),  # include panel with the title (also sets browser title)
sidebarLayout(   # layout the page in two columns
sidebarPanel(  # specify content for the "sidebar" column
p("sidebar panel content goes here")
),
mainPanel(     # specify content for the "main" column
p("main panel content goes here")
)
)
)
runApp('Untitled.R')
install.packages("shiny")
runApp('Untitled.R')
install.packages("shiny")
install.packages("shiny")
library(shiny); runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Desktop/Info201/pineapple-tribe-final')
runApp('Desktop/Info201/pineapple-tribe-final')
install.packages("shinythemes")
runApp('Desktop/Info201/pineapple-tribe-final')
both <- read.csv("marriage/both_sexes.csv",stringsAsFactors = FALSE)
setwd("~/Desktop/Info201/pineapple-tribe-final")
both <- read.csv("marriage/both_sexes.csv",stringsAsFactors = FALSE)
View(both)
runApp()
runApp()
both <- both %>% select(year,4:27)
runApp()
runApp()
both <- both %>% select(year,3:7)
runApp()
both <- melt(both,id="year")
runApp()
both <- melt(both,id="year")
both
both <- read.csv("marriage/both_sexes.csv",stringsAsFactors = FALSE)
both <- both %>% select(year,4:27)
both <- both %>% select(year,3:7)
both <- melt(both,id="year")
both
both <- read.csv("marriage/both_sexes.csv",stringsAsFactors = FALSE)
runApp()
both <- both %>% select(year,4:27)
both <- both %>% select(year,3:7)
colnames(both) <- c("High school graduate or less","Some college","Bachelor's degree or more","Bachelor's degree, no graduate degre","Graduate degree")
both
both <- melt(both,id="year")
runApp()
